import arcpy
from arcpy import env
import numpy as np
import os
import time

######### Define parameters
usngCellsGDB = arcpy.GetParameterAsText(0) ## The GDB that stores the enriched USNGS cells. Each cell includes the ACS demographic data
GridCellsSize = arcpy.GetParameterAsText(1) ## Either 1 or 5 (km)
parcelsInAffectedArea = arcpy.GetParameterAsText(2) ## A layer with the enriched parcels. Each parcel also includes flood depth and wind probability
ParcelsHazardFields = arcpy.GetParameterAsText(3) ## Hazard fields (a string containing the hazard fields. can be multiple or null)
outputFolder = arcpy.GetParameterAsText(4) ## The GDB that will store the output
EventName = arcpy.GetParameterAsText(5) ## add an event name to the output

### NOTE- parameters #5 - 17 store the weights of the social vulnerability criteria####

arcpy.env.workspace = outputFolder
arcpy.env.overwriteOutput = True

## Master GDB

MasterGDB5KM = "//hqmac3f1/Static/GISdata/POST_Results_Master/POST_Master_Results.gdb/POST_5KM_Results_EP"
MasterGDB1KM = "//hqmac3f1/Static/GISdata/POST_Results_Master/POST_Master_Results.gdb/POST_1KM_Results_EP"



usngCells =  usngCellsGDB + "/EnrichedUSNG18_" + GridCellsSize + "KM"## The name of USNG feautre class
GridCellsName = "usng" + GridCellsSize + "km" ## The name of the field that stores a unique name of the USNG cell
SourceFile = ("POST" + "_" + GridCellsSize + "KM" + "CellsWithPriorities" + "_2020")


exp = '''def add_date():
  import time
  return time.strftime("%Y/%m/%d")'''

TodayTime = datetime.datetime.now().strftime("%Y%m%d_%H%M")



## Identify the most severely affected USNG cells

## First, determine if any hazard attributes (e.g. wind speed, flood depth) were selected.
## Note, if no hazard attributes were selected, only account of the number of structures in a cell.
## i.e. add to the parcels layer a temporary field, which will store a contant value ("1"):

GDBname = "POST" + "_" + GridCellsSize + "KM_" + EventName
if arcpy.Exists(outputFolder +"/" + GDBname + ".gdb"):

     

    fullPath = os.path.join(workspace, FDSName)
    print (fullPath)
    #arcpy.env.workspace = fullPath
    arcpy.env.workspace = outputFolder + "/" + GDBname + ".gdb"
    arcpy.env.overwriteOutput = True

    if ParcelsHazardFields == "":
        listofHazardParameters = []
    else:
        listofHazardParameters = [x.strip() for x in ParcelsHazardFields.split(";")] ## This array stores the list of hazard parameters

    numOfHazardParameters = int(len(listofHazardParameters)) ## count nuber of items in list

    arcpy.management.MakeFeatureLayer(usngCells, "USNGLyr")

    if numOfHazardParameters == 0: ## if the number of items is 0
        arcpy.AddField_management("usngOverParcelsLyr", "constHazard", "SHORT") ## add a field named "constHazard"
        arcpy.management.CalculateField("usngOverParcelsLyr", "constHazard", 1, "PYTHON3", None) ## populate it with a value "1"
        listofHazardParameters.append("constHazard") ## and add it to the list of hazard parameters

    ## Select the USNG cells that intersect with the affected parcels
    arcpy.management.MakeFeatureLayer(parcelsInAffectedArea, "ParcelsLyr", None, None,None)

    for item in listofHazardParameters:
        arcpy.management.SelectLayerByAttribute("ParcelsLyr", "NEW_SELECTION", item +" IS NULL", None)
        arcpy.management.CalculateField("ParcelsLyr", item, 0, "PYTHON3", None)
        arcpy.management.SelectLayerByAttribute("ParcelsLyr", "CLEAR_SELECTION", None, None)

    
    arcpy.management.SelectLayerByLocation("USNGLyr", "INTERSECT", "ParcelsLyr", None, "NEW_SELECTION", "NOT_INVERT")
    arcpy.management.CopyFeatures("USNGLyr", "usngOverParcels", None, None, None, None)
    arcpy.management.MakeFeatureLayer("usngOverParcels", "usngOverParcelsLyr", None, None,None)

    ## Add fields that will store the total hazard probabilty score and the relative rank
    arcpy.AddField_management("usngOverParcelsLyr", "hazardTotalScore", "SHORT")
    arcpy.AddField_management("usngOverParcelsLyr", "Hazard_Rank", "SHORT")



    
    ## join the parcel layer with the USNG grid cells
    arcpy.analysis.SpatialJoin("ParcelsLyr", "usngOverParcelsLyr", "ParcelsWithUSNGCellID", "JOIN_ONE_TO_ONE", "KEEP_ALL")
    ## Each parcel now includes the ID of the overlapping USNG cell
    time.sleep(120)

    ## Calculate for each cell and for each hazard property a hazard rank and a relative rank.
    ## The rank (1-10) will be stored in a field that has the name of the hazard + "C" in the end of the name
    for item in listofHazardParameters:
        arcpy.management.SelectLayerByAttribute("usngOverParcelsLyr", "CLEAR_SELECTION", None, None)
        arcpy.AddField_management("usngOverParcelsLyr", item+"C", "SHORT")
        ##arcpy.management.Delete(outputGDB + "\ParcelsWithUSNGCellIDStats" + item, None) ## just in case, because the overwrite does not seem to work with tables...

        time.sleep(120)
        arcpy.analysis.Statistics("ParcelsWithUSNGCellID", "ParcelsWithUSNGCellIDStats" + item, item + " SUM", GridCellsName)
        ## The field SUM_ + item is the sum value of all the parcels within a given USNG cell 
        arcpy.management.JoinField("usngOverParcelsLyr", GridCellsName, "ParcelsWithUSNGCellIDStats" + item, GridCellsName, "SUM_" + item)


        ## calculate the percentile rank of each hazard property
        arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsLyr", "SUM_" + item)
        arr = np.array(arrp,np.float)
        p1 = np.percentile(arr, 20)
        p2 = np.percentile(arr, 30)
        p3 = np.percentile(arr, 40)
        p4 = np.percentile(arr, 50)
        p5 = np.percentile(arr, 60)
        p6 = np.percentile(arr, 70)
        p7 = np.percentile(arr, 80)
        p8 = np.percentile(arr, 90)
        p9 = np.percentile(arr, 95)

        with arcpy.da.UpdateCursor("usngOverParcelsLyr", ["SUM_" + item, item+"C"]) as cursor:
            for row in cursor:
                if row[0] <= p1:
                    row[1] = 1
                elif p1 <= row[0] and row[0] < p2:    
                    row[1] = 2
                elif p2 <= row[0] and row[0] < p3:     
                    row[1] = 3
                elif p3 <= row[0] and row[0] < p4:    
                    row[1] = 4
                elif p4 <= row[0] and row[0] < p5:    
                    row[1] = 5
                elif p5 <= row[0] and row[0] < p6:
                    row[1] = 6
                elif p6 <= row[0] and row[0] < p7:    
                    row[1] = 7
                elif p7 <= row[0] and row[0] < p8:
                    row[1] = 8
                elif p8 <= row[0] and row[0] < p9:
                    row[1] = 9
                else:    
                    row[1] = 10
                cursor.updateRow(row)

    ## Calculate for each cell the total hazard score (the sum of the ranks of each hazard criterion)
    forCalcTotalHazardSumCmdStr = ' + '.join(['!%sC!' % item for item in listofHazardParameters]) ## This is just the expression for the next line
    arcpy.management.CalculateField("usngOverParcelsLyr", "hazardTotalScore", forCalcTotalHazardSumCmdStr, "PYTHON3", None)

    ## now we want to rank the cells, relatively, according to the total hazard score.
    ## The relative rank (according to the percentile group) will be sotred in the field "Hazard_Rank")

    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsLyr", "hazardTotalScore")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsLyr", ["hazardTotalScore", 'Hazard_Rank']) as cursor:
        for row in cursor:
            if row[0] <= p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    ## Identify the cells with the highest rank (above the median value)
    arcpy.management.SelectLayerByAttribute("usngOverParcelsLyr", "NEW_SELECTION", "Hazard_Rank >= 6", None)
    arcpy.management.CopyFeatures("usngOverParcelsLyr",  "usngOverParcelsAboveMedian", None, None, None, None)
    arcpy.management.MakeFeatureLayer( "usngOverParcelsAboveMedian", "usngOverParcelsAboveMedianLyr", None, None,None)


    ###########SOCIAL VULNERABILITY###############

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "TotalPopScore", "SHORT")## A field that will store for each cell the sum percentile rank value of all the SV properties 
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "SV_Score_Rank_NonWeighted", "SHORT") ## A field that will store for each cell the relative percentile rank of the cells relative to all the affected cells
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted", "SHORT") ## A field that will store for each cell the WEIGHTED sum percentile rank value of all the SV properties(weighted by the weight in the parameters)
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "SV_Score_Rank_Weighted", "SHORT") ## A field that will store for each cell the relative percentile rank of the cells (weighted) 

    ## A constant list of the social vulnerability properties, in the order put in the parameters
    listofFeatures = ["pop","households", "housingunits", "pop65over", "pop16overunemployed", "pop16overnotinlaborforce", "popamindianalaskan", "householdsinpoverty", "householdsdsfs", "householdsdsnofs",
                  "householdswithfs", "householdswithpa", "housingunitsmobilehomes"]

    uiParamsBeforeFeatures = 6 ## we have (in the tool`s parameter list) 5 parameters before the first social vulnerability parameter

    ## Define a dictionary that will store an index number and the weight of the parameter
    weightParamDict = {} 
    for (ii, item) in enumerate(listofFeatures):
        weightParamDict[item] = int(arcpy.GetParameterAsText(ii + uiParamsBeforeFeatures))


    use_parameter_list = []

    for item in weightParamDict.keys():
        if weightParamDict[item] > 0:
            use_parameter_list.append(item)
        
    for item in use_parameter_list:
        arcpy.AddField_management("usngOverParcelsAboveMedianLyr", item+"C", "SHORT")
    
    for item in use_parameter_list:
        arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", item)
        arr = np.array(arrp,np.float)
        p1 = np.percentile(arr, 20)
        p2 = np.percentile(arr, 30)
        p3 = np.percentile(arr, 40)
        p4 = np.percentile(arr, 50)
        p5 = np.percentile(arr, 60)
        p6 = np.percentile(arr, 70)
        p7 = np.percentile(arr, 80)
        p8 = np.percentile(arr, 90)
        p9 = np.percentile(arr, 95)

        with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", [item, item+"C"]) as cursor:
            for row in cursor:
                if row[0] <= p1:
                    row[1] = 1
                elif p1 <= row[0] and row[0] < p2:    
                    row[1] = 2
                elif p2 <= row[0] and row[0] < p3:     
                    row[1] = 3
                elif p3 <= row[0] and row[0] < p4:    
                    row[1] = 4
                elif p4 <= row[0] and row[0] < p5:    
                    row[1] = 5
                elif p5 <= row[0] and row[0] < p6:
                    row[1] = 6
                elif p6 <= row[0] and row[0] < p7:    
                    row[1] = 7
                elif p7 <= row[0] and row[0] < p8:
                    row[1] = 8
                elif p8 <= row[0] and row[0] < p9:
                    row[1] = 9
                else:    
                    row[1] = 10
                cursor.updateRow(row)

    forCalcSumCmdStr = ' + '.join(['!%sC!' % item for item in use_parameter_list])
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "TotalPopScore", forCalcSumCmdStr, "PYTHON3", None)


    forCalcWeightedSumCmdStr = ' + '.join(['!%sC! * %d' % (item,weightParamDict[item]) for item in use_parameter_list])
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted", forCalcWeightedSumCmdStr, "PYTHON3", None)


    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", "TotalPopScore")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", ['TotalPopScore', 'SV_Score_Rank_NonWeighted']) as cursor:
        for row in cursor:
            if row[0] <= p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", ['TotalPopScoreWeighted', 'SV_Score_Rank_Weighted']) as cursor:
        for row in cursor:
            if row[0] < p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", "SHORT")
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", "SHORT")


    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted <= 3", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 3, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted > 3 And SV_Score_Rank_NonWeighted <= 7", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 2, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted >= 8 And SV_Score_Rank_NonWeighted <= 10", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 1, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "CLEAR_SELECTION", None, None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted <= 3", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 3, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted > 3 And SV_Score_Rank_Weighted <= 7", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 2, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted >= 8 And SV_Score_Rank_Weighted <= 10", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 1, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "CLEAR_SELECTION", None, None)

        #todayIs = time.strftime('%m_%d_%y')
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Date", "DATE")
    #arcpy.management.CalculateField("usngOverParcelsLyr", "Date", 'add_date()' , "PYTHON3", exp)
   

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Event", "TEXT")
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Event", "'" + EventName + "'", "PYTHON3")

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Comments", "TEXT")

    #arcpy.management.CalculateField("usngOverParcelsLyr", "Event", '"Brooke"', "PYTHON3", '', "TEXT")'''


    ## Clean fields

    for item in use_parameter_list:
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", item + "C")
    for item in listofHazardParameters:
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "SUM_" + item)
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", item + "C")
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "TOTALC")
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "SUM_TOTAL")

    

    #todayIs = time.strftime('%m_%d_%y')
    #arcpy.management.CopyFeatures("usngOverParcelsAboveMedianLyr", EventName + "_" + "USNG" + "_" + GridCellsSize + "KM" + "CellsWithPriorities_" + todayIs , None, None, None, None)


    

     ## Clean fields
    outputz = "POST" + "_" + GridCellsSize + "KM_" + EventName + "_" + TodayTime

    #todayIs = time.strftime('%m_%d_%y')
    UniqueFile = arcpy.management.CopyFeatures("usngOverParcelsAboveMedianLyr","POST" + "_" + GridCellsSize + "KM_" + EventName + "_" + TodayTime, None, None, None, None)
    with arcpy.da.UpdateCursor(UniqueFile, "Date") as rows:
        for row in rows:
            rows.updateRow([datetime.datetime.now().strftime("%Y/%m/%d %H:%M")])
    #arcpy.management.Append(UniqueFile, SourceFile, "TEST")
    if "5KM" in outputz:
        arcpy.management.Append(UniqueFile, MasterGDB5KM, "TEST")
        
    else:
        arcpy.management.Append(UniqueFile, MasterGDB1KM, "TEST")

    '''draftFileName = outputGDB + "\AOI_Tasker_Parameters_" + todayIs+ ".txt"
    draftFile = open(draftFileName, 'w')
    test =draftFile.write("today is:%s" % todayIs)'''


else:


    #Create GBB for event outputs
    sr = arcpy.SpatialReference("WGS 1984 World Mercator")
    GDBname = "POST" + "_" + GridCellsSize + "KM_" + EventName
    FDname = "POST" + "_" + GridCellsSize + "KM_" + EventName
    POSTGDB = arcpy.CreateFileGDB_management(outputFolder, GDBname)
    POSTFD = arcpy.CreateFeatureDataset_management(POSTGDB,  FDname, sr)
    


    
    arcpy.env.workspace = outputFolder + "/" + GDBname + ".gdb"
    #arcpy.env.overwriteOutput = True
    


    if ParcelsHazardFields == "":
        listofHazardParameters = []
    else:
        listofHazardParameters = [x.strip() for x in ParcelsHazardFields.split(";")] ## This array stores the list of hazard parameters

    numOfHazardParameters = int(len(listofHazardParameters)) ## count nuber of items in list

    arcpy.management.MakeFeatureLayer(usngCells, "USNGLyr")

    if numOfHazardParameters == 0: ## if the number of items is 0
        arcpy.AddField_management("usngOverParcelsLyr", "constHazard", "SHORT") ## add a field named "constHazard"
        arcpy.management.CalculateField("usngOverParcelsLyr", "constHazard", 1, "PYTHON3", None) ## populate it with a value "1"
        listofHazardParameters.append("constHazard") ## and add it to the list of hazard parameters

    ## Select the USNG cells that intersect with the affected parcels
    arcpy.management.MakeFeatureLayer(parcelsInAffectedArea, "ParcelsLyr", None, None,None)

    for item in listofHazardParameters:
        arcpy.management.SelectLayerByAttribute("ParcelsLyr", "NEW_SELECTION", item +" IS NULL", None)
        arcpy.management.CalculateField("ParcelsLyr", item, 0, "PYTHON3", None)
        arcpy.management.SelectLayerByAttribute("ParcelsLyr", "CLEAR_SELECTION", None, None)

    
    arcpy.management.SelectLayerByLocation("USNGLyr", "INTERSECT", "ParcelsLyr", None, "NEW_SELECTION", "NOT_INVERT")
    arcpy.management.CopyFeatures("USNGLyr", "usngOverParcels", None, None, None, None)
    arcpy.management.MakeFeatureLayer("usngOverParcels", "usngOverParcelsLyr", None, None,None)

    ## Add fields that will store the total hazard probabilty score and the relative rank
    arcpy.AddField_management("usngOverParcelsLyr", "hazardTotalScore", "SHORT")
    arcpy.AddField_management("usngOverParcelsLyr", "Hazard_Rank", "SHORT")



    
    ## join the parcel layer with the USNG grid cells
    arcpy.analysis.SpatialJoin("ParcelsLyr", "usngOverParcelsLyr", "ParcelsWithUSNGCellID", "JOIN_ONE_TO_ONE", "KEEP_ALL")
    ## Each parcel now includes the ID of the overlapping USNG cell
    time.sleep(120)

    ## Calculate for each cell and for each hazard property a hazard rank and a relative rank.
    ## The rank (1-10) will be stored in a field that has the name of the hazard + "C" in the end of the name
    for item in listofHazardParameters:
        arcpy.management.SelectLayerByAttribute("usngOverParcelsLyr", "CLEAR_SELECTION", None, None)
        arcpy.AddField_management("usngOverParcelsLyr", item+"C", "SHORT")
        ##arcpy.management.Delete(outputGDB + "\ParcelsWithUSNGCellIDStats" + item, None) ## just in case, because the overwrite does not seem to work with tables...

        time.sleep(120)
        arcpy.analysis.Statistics("ParcelsWithUSNGCellID", "ParcelsWithUSNGCellIDStats" + item, item + " SUM", GridCellsName)
        ## The field SUM_ + item is the sum value of all the parcels within a given USNG cell 
        arcpy.management.JoinField("usngOverParcelsLyr", GridCellsName, "\ParcelsWithUSNGCellIDStats" + item, GridCellsName, "SUM_" + item)


        ## calculate the percentile rank of each hazard property
        arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsLyr", "SUM_" + item)
        arr = np.array(arrp,np.float)
        p1 = np.percentile(arr, 20)
        p2 = np.percentile(arr, 30)
        p3 = np.percentile(arr, 40)
        p4 = np.percentile(arr, 50)
        p5 = np.percentile(arr, 60)
        p6 = np.percentile(arr, 70)
        p7 = np.percentile(arr, 80)
        p8 = np.percentile(arr, 90)
        p9 = np.percentile(arr, 95)

        with arcpy.da.UpdateCursor("usngOverParcelsLyr", ["SUM_" + item, item+"C"]) as cursor:
            for row in cursor:
                if row[0] <= p1:
                    row[1] = 1
                elif p1 <= row[0] and row[0] < p2:    
                    row[1] = 2
                elif p2 <= row[0] and row[0] < p3:     
                    row[1] = 3
                elif p3 <= row[0] and row[0] < p4:    
                    row[1] = 4
                elif p4 <= row[0] and row[0] < p5:    
                    row[1] = 5
                elif p5 <= row[0] and row[0] < p6:
                    row[1] = 6
                elif p6 <= row[0] and row[0] < p7:    
                    row[1] = 7
                elif p7 <= row[0] and row[0] < p8:
                    row[1] = 8
                elif p8 <= row[0] and row[0] < p9:
                    row[1] = 9
                else:    
                    row[1] = 10
                cursor.updateRow(row)

    ## Calculate for each cell the total hazard score (the sum of the ranks of each hazard criterion)
    forCalcTotalHazardSumCmdStr = ' + '.join(['!%sC!' % item for item in listofHazardParameters]) ## This is just the expression for the next line
    arcpy.management.CalculateField("usngOverParcelsLyr", "hazardTotalScore", forCalcTotalHazardSumCmdStr, "PYTHON3", None)

    ## now we want to rank the cells, relatively, according to the total hazard score.
    ## The relative rank (according to the percentile group) will be sotred in the field "Hazard_Rank")

    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsLyr", "hazardTotalScore")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsLyr", ["hazardTotalScore", 'Hazard_Rank']) as cursor:
        for row in cursor:
            if row[0] <= p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    ## Identify the cells with the highest rank (above the median value)
    arcpy.management.SelectLayerByAttribute("usngOverParcelsLyr", "NEW_SELECTION", "Hazard_Rank >= 6", None)
    arcpy.management.CopyFeatures("usngOverParcelsLyr", "usngOverParcelsAboveMedian", None, None, None, None)
    arcpy.management.MakeFeatureLayer( "usngOverParcelsAboveMedian", "usngOverParcelsAboveMedianLyr", None, None,None)


    ###########SOCIAL VULNERABILITY###############

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "TotalPopScore", "SHORT")## A field that will store for each cell the sum percentile rank value of all the SV properties 
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "SV_Score_Rank_NonWeighted", "SHORT") ## A field that will store for each cell the relative percentile rank of the cells relative to all the affected cells
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted", "SHORT") ## A field that will store for each cell the WEIGHTED sum percentile rank value of all the SV properties(weighted by the weight in the parameters)
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "SV_Score_Rank_Weighted", "SHORT") ## A field that will store for each cell the relative percentile rank of the cells (weighted) 

    ## A constant list of the social vulnerability properties, in the order put in the parameters
    listofFeatures = ["pop","households", "housingunits", "pop65over", "pop16overunemployed", "pop16overnotinlaborforce", "popamindianalaskan", "householdsinpoverty", "householdsdsfs", "householdsdsnofs",
                  "householdswithfs", "householdswithpa", "housingunitsmobilehomes"]

    uiParamsBeforeFeatures = 6 ## we have (in the tool`s parameter list) 5 parameters before the first social vulnerability parameter

    ## Define a dictionary that will store an index number and the weight of the parameter
    weightParamDict = {} 
    for (ii, item) in enumerate(listofFeatures):
        weightParamDict[item] = int(arcpy.GetParameterAsText(ii + uiParamsBeforeFeatures))


    use_parameter_list = []

    for item in weightParamDict.keys():
        if weightParamDict[item] > 0:
            use_parameter_list.append(item)
        
    for item in use_parameter_list:
        arcpy.AddField_management("usngOverParcelsAboveMedianLyr", item+"C", "SHORT")
    
    for item in use_parameter_list:
        arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", item)
        arr = np.array(arrp,np.float)
        p1 = np.percentile(arr, 20)
        p2 = np.percentile(arr, 30)
        p3 = np.percentile(arr, 40)
        p4 = np.percentile(arr, 50)
        p5 = np.percentile(arr, 60)
        p6 = np.percentile(arr, 70)
        p7 = np.percentile(arr, 80)
        p8 = np.percentile(arr, 90)
        p9 = np.percentile(arr, 95)

        with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", [item, item+"C"]) as cursor:
            for row in cursor:
                if row[0] <= p1:
                    row[1] = 1
                elif p1 <= row[0] and row[0] < p2:    
                    row[1] = 2
                elif p2 <= row[0] and row[0] < p3:     
                    row[1] = 3
                elif p3 <= row[0] and row[0] < p4:    
                    row[1] = 4
                elif p4 <= row[0] and row[0] < p5:    
                    row[1] = 5
                elif p5 <= row[0] and row[0] < p6:
                    row[1] = 6
                elif p6 <= row[0] and row[0] < p7:    
                    row[1] = 7
                elif p7 <= row[0] and row[0] < p8:
                    row[1] = 8
                elif p8 <= row[0] and row[0] < p9:
                    row[1] = 9
                else:    
                    row[1] = 10
                cursor.updateRow(row)

    forCalcSumCmdStr = ' + '.join(['!%sC!' % item for item in use_parameter_list])
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "TotalPopScore", forCalcSumCmdStr, "PYTHON3", None)


    forCalcWeightedSumCmdStr = ' + '.join(['!%sC! * %d' % (item,weightParamDict[item]) for item in use_parameter_list])
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted", forCalcWeightedSumCmdStr, "PYTHON3", None)


    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", "TotalPopScore")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", ['TotalPopScore', 'SV_Score_Rank_NonWeighted']) as cursor:
        for row in cursor:
            if row[0] <= p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    arrp = arcpy.da.FeatureClassToNumPyArray("usngOverParcelsAboveMedianLyr", "TotalPopScoreWeighted")
    arr = np.array(arrp,np.float)
    p1 = np.percentile(arr, 20)
    p2 = np.percentile(arr, 30)
    p3 = np.percentile(arr, 40)
    p4 = np.percentile(arr, 50)
    p5 = np.percentile(arr, 60)
    p6 = np.percentile(arr, 70)
    p7 = np.percentile(arr, 80)
    p8 = np.percentile(arr, 90)
    p9 = np.percentile(arr, 95)

    with arcpy.da.UpdateCursor("usngOverParcelsAboveMedianLyr", ['TotalPopScoreWeighted', 'SV_Score_Rank_Weighted']) as cursor:
        for row in cursor:
            if row[0] < p1:
                row[1] = 1
            elif p1 <= row[0] and row[0] < p2:    
                row[1] = 2
            elif p2 <= row[0] and row[0] < p3:     
                row[1] = 3
            elif p3 <= row[0] and row[0] < p4:    
                row[1] = 4
            elif p4 <= row[0] and row[0] < p5:    
                row[1] = 5
            elif p5 <= row[0] and row[0] < p6:
                row[1] = 6
            elif p6 <= row[0] and row[0] < p7:    
                row[1] = 7
            elif p7 <= row[0] and row[0] < p8:
                row[1] = 8
            elif p8 <= row[0] and row[0] < p9:
                row[1] = 9
            else:    
                row[1] = 10
            cursor.updateRow(row)

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", "SHORT")
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", "SHORT")


    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted <= 3", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 3, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted > 3 And SV_Score_Rank_NonWeighted <= 7", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 2, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_NonWeighted >= 8 And SV_Score_Rank_NonWeighted <= 10", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Non_Weighted", 1, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "CLEAR_SELECTION", None, None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted <= 3", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 3, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted > 3 And SV_Score_Rank_Weighted <= 7", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 2, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "NEW_SELECTION", "SV_Score_Rank_Weighted >= 8 And SV_Score_Rank_Weighted <= 10", None)
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Collection_Priority_Weighted", 1, "PYTHON3", None)

    arcpy.management.SelectLayerByAttribute("usngOverParcelsAboveMedianLyr", "CLEAR_SELECTION", None, None)

      
    #todayIs = time.strftime('%m_%d_%y')
    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Date", "DATE")
    #arcpy.management.CalculateField("usngOverParcelsLyr", "Date", 'add_date()' , "PYTHON3", exp)
   

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Event", "TEXT")
    arcpy.management.CalculateField("usngOverParcelsAboveMedianLyr", "Event", "'" + EventName + "'", "PYTHON3")

    arcpy.AddField_management("usngOverParcelsAboveMedianLyr", "Comments", "TEXT")

    #arcpy.management.CalculateField("usngOverParcelsLyr", "Event", '"Brooke"', "PYTHON3", '', "TEXT")'''


    ## Clean fields

    for item in use_parameter_list:
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", item + "C")
    for item in listofHazardParameters:
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "SUM_" + item)
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", item + "C")
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "TOTALC")
        arcpy.management.DeleteField("usngOverParcelsAboveMedianLyr", "SUM_TOTAL")

    

    #todayIs = time.strftime('%m_%d_%y')
    #arcpy.management.CopyFeatures("usngOverParcelsAboveMedianLyr", EventName + "_" + "USNG" + "_" + GridCellsSize + "KM" + "CellsWithPriorities_" + todayIs , None, None, None, None)



    Outputz = "POST" + "_" + GridCellsSize + "KM_" + EventName + "_" + TodayTime
    todayIs = time.strftime('%m_%d_%y')
    fc = arcpy.management.CopyFeatures("usngOverParcelsAboveMedianLyr",  "POST" + "_" + GridCellsSize + "KM_" + EventName + "_" + TodayTime, None, None, None, None)
    with arcpy.da.UpdateCursor(fc, "Date") as rows:
        for row in rows:
            rows.updateRow([datetime.datetime.now().strftime("%Y/%m/%d %H:%M")])
    print ('done')



print ("Done")
